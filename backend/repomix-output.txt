This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
dao/
  __init__.py
  course_repository.py
  student_repository.py
data/
  courses.sql
  students_courses.sql
  students.sql
model/
  __init__.py
  course.py
  student.py
routes/
  course_routes.py
  student_routes.py
service/
  __init__.py
  course_service.py
  student_service.py
sql/
  course.sql
  student_course.sql
  student.sql
tests/
  test_app.py
  test_courses.py
  test_students.py
.editorconfig
.gitignore
.tool-versions
app.py
db.py
Justfile
logging_config.py
pyproject.toml
README.md
server.py

================================================================
Files
================================================================

================
File: dao/__init__.py
================
from .course_repository import CourseRepository
from .student_repository import StudentRepository

__all__ = [
    "CourseRepository",
    "StudentRepository",
]

================
File: dao/course_repository.py
================
from sqlalchemy import text

from model.course import Course


class CourseRepository:
    def get_course_by_id(self, course_id: int, db) -> Course:
        SQL = text("""
            SELECT course_id, course_name, credits, department, semester, year
            FROM course
            WHERE course_id = :course_id
        """)
        result = db.execute(SQL, {"course_id": course_id})
        row = result.mappings().first()

        if not row:
            raise ValueError(f"Course with ID {course_id} not found")

        return Course(**row)

    def get_all_courses(self, db) -> list[Course]:
        SQL = text("""
            SELECT course_id, course_name, credits, department, semester, year
            FROM course
        """)
        result = db.execute(SQL)
        rows = result.mappings().all()

        if not rows:
            return []

        courses = [Course(**row) for row in rows]
        return courses

    def create_course(self, course_data: dict, db) -> Course:
        SQL = text("""
            INSERT INTO course (course_name, credits, department, semester, year)
            VALUES (:course_name, :credits, :department, :semester, :year)
        """)
        result = db.execute(SQL, course_data)
        db.commit()
        new_id = result.lastrowid

        if not new_id:
            raise ValueError("Failed to create course")

        return self.get_course_by_id(new_id, db)

    def update_course(self, course_id: int, course_data: dict, db) -> Course:
        SQL = text("""
            UPDATE course
            SET course_name = :course_name,
                credits = :credits,
                department = :department,
                semester = :semester,
                year = :year
            WHERE course_id = :course_id
        """)
        result = db.execute(SQL, {**course_data, "course_id": course_id})
        db.commit()

        if result.rowcount == 0:
            raise ValueError(f"Course with ID {course_id} not found")

        return self.get_course_by_id(course_id, db)

    def delete_course(self, course_id: int, db) -> None:
        SQL = text("""
            DELETE FROM course
            WHERE course_id = :course_id
        """)
        result = db.execute(SQL, {"course_id": course_id})
        db.commit()

        if result.rowcount == 0:
            raise ValueError(f"Course with ID {course_id} not found")

================
File: dao/student_repository.py
================
from sqlalchemy import text

from model import Student


class StudentRepository:
    def get_student_by_id(self, student_id: int, db) -> Student:
        SQL = text("""
            SELECT student_id, name, age, enroll_year, major, gpa
            FROM student
            WHERE student_id = :student_id
        """)
        result = db.execute(SQL, {"student_id": student_id})
        row = result.mappings().first()

        if not row:
            raise ValueError(f"Student with ID {student_id} not found")

        return Student(**row)

    def get_all_students(self, db) -> list[Student]:
        SQL = text("""
            SELECT student_id, name, age, enroll_year, major, gpa
            FROM student
        """)
        result = db.execute(SQL)
        rows = result.mappings().all()

        if not rows:
            return []

        students = [Student(**dict(row)) for row in rows]
        return students

    def create_student(self, student_data: dict, db) -> Student:
        SQL = text("""
            INSERT INTO student (name, age, enroll_year, major, gpa)
            VALUES (:name, :age, :enroll_year, :major, :gpa)
        """)
        result = db.execute(SQL, student_data)
        db.commit()
        new_id = result.lastrowid

        if not new_id:
            raise ValueError("Failed to create student")
        return self.get_student_by_id(new_id, db)

    def update_student(self, student_id: int, student_data: dict, db) -> Student:
        SQL = text("""
            UPDATE student
            SET name = :name, age = :age, enroll_year = :enroll_year, major = :major, gpa = :gpa
            WHERE student_id = :student_id
        """)
        result = db.execute(SQL, {**student_data, "student_id": student_id})
        db.commit()

        if result.rowcount == 0:
            raise ValueError(f"Student with ID {student_id} not found")

        return self.get_student_by_id(student_id, db)

    def delete_student(self, student_id: int, db) -> None:
        SQL = text("""
            DELETE FROM student
            WHERE student_id = :student_id
        """)
        result = db.execute(SQL, {"student_id": student_id})
        db.commit()

        if result.rowcount == 0:
            raise ValueError(f"Student with ID {student_id} not found")

================
File: data/courses.sql
================
INSERT INTO course
  (course_id, course_name, credits, department, semester, year)
VALUES
  (1, 'Introduction to Programming', 3, 'Computer Science', 'Fall', 2023),
  (2, 'Data Structures', 3, 'Computer Science', 'Spring', 2024),
  (3, 'Database Systems', 3, 'Computer Science', 'Fall', 2024),
  (4, 'Operating Systems', 3, 'Computer Science', 'Spring', 2025),
  (5, 'Web Development', 3, 'Computer Science', 'Fall', 2025),
  (6, 'Machine Learning', 3, 'Computer Science', 'Spring', 2026);

================
File: data/students_courses.sql
================
-- seed data for student_course table
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (1, 1, 'Fall', 'A');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (1, 2, 'Spring', 'B');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (2, 1, 'Fall', 'C');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (2, 3, 'Spring', 'A');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (3, 2, 'Fall', 'B');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (3, 4, 'Spring', 'A');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (4, 5, 'Fall', 'C');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (5, 6, 'Spring', 'B');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (6, 1, 'Fall', 'A');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (1, 3, 'Fall', 'A');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (2, 4, 'Spring', 'C');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (3, 5, 'Fall', 'B');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (4, 6, 'Spring', 'A');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (5, 1, 'Fall', 'C');
INSERT INTO student_course (student_id, course_id, semester, grade) VALUES (6, 2, 'Spring', 'B');

================
File: data/students.sql
================
INSERT INTO student
  (student_id, name, age, enroll_year, major, gpa)
VALUES
  (1, 'Alice Smith', 20, 2022, 'Computer Science', 3.8),
  (2, 'Bob Johnson', 21, 2021, 'Mathematics', 3.5),
  (3, 'Charlie Brown', 22, 2020, 'Physics', 3.9),
  (4, 'Diana Prince', 19, 2023, 'Computer Science', 3.7),
  (5, 'Ethan Hunt', 23, 2019, 'Engineering', 3.6),
  (6, 'Fiona Apple', 20, 2022, 'Biology', 3.4);

================
File: model/__init__.py
================
from .course import Course, CourseCreate
from .student import Student, StudentCreate

__all__ = [
    "Course",
    "CourseCreate",
    "Student",
    "StudentCreate",
]

================
File: model/course.py
================
from pydantic import BaseModel


class Course(BaseModel):
    course_id: int
    course_name: str
    credits: int
    department: str
    semester: str
    year: int


class CourseCreate(BaseModel):
    course_name: str
    credits: int
    department: str
    semester: str
    year: int

================
File: model/student.py
================
from pydantic import BaseModel


class Student(BaseModel):
    student_id: int
    name: str
    age: int
    enroll_year: int
    major: str
    gpa: float


class StudentCreate(BaseModel):
    name: str
    age: int
    enroll_year: int
    major: str
    gpa: float

================
File: routes/course_routes.py
================
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

import logging_config
from db import get_db
from model import Course, CourseCreate
from service import CourseService

logger = logging_config.get_logger(__name__)
router = APIRouter(prefix="/courses", tags=["courses"])
course_service = CourseService()


@router.get("/{course_id}", response_model=Course)
def read_course(course_id: int, db: Session = Depends(get_db)):
    logger.info(f"Fetching course with ID: {course_id}")
    try:
        course = course_service.get_course(course_id, db)
        return course.model_dump()
    except ValueError as e:
        logger.error(f"Error fetching course with ID {course_id}: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))


@router.get("/", response_model=list[Course])
def read_courses(db: Session = Depends(get_db)):
    logger.info("Fetching all courses")
    try:
        courses = course_service.get_courses(db)
        return [course.model_dump() for course in courses]
    except ValueError as e:
        logger.error(f"Error fetching courses: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))


@router.post("/", response_model=Course)
def create_course(course_data: CourseCreate, db: Session = Depends(get_db)):
    logger.info(f"Creating new course with data: {course_data.model_dump()}")
    try:
        new_course = course_service.create_course(course_data.model_dump(), db)
        return new_course.model_dump()
    except ValueError as e:
        logger.error(f"Error creating course: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))


@router.put("/{course_id}", response_model=Course)
def update_course(
    course_id: int, course_data: CourseCreate, db: Session = Depends(get_db)
):
    logger.info(
        f"Updating course with ID: {course_id} with data: {course_data.model_dump()}"
    )
    try:
        updated_course = course_service.update_course(
            course_id, course_data.model_dump(), db
        )
        return updated_course.model_dump()
    except ValueError as e:
        logger.error(f"Error updating course with ID {course_id}: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error while updating course: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/{course_id}")
def delete_course(course_id: int, db: Session = Depends(get_db)):
    logger.info(f"Deleting course with ID: {course_id}")
    try:
        course_service.delete_course(course_id, db)
        return {"detail": f"Course with ID {course_id} deleted successfully"}
    except ValueError as e:
        logger.error(f"Error deleting course with ID {course_id}: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error while deleting course: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

================
File: routes/student_routes.py
================
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

import logging_config
from db import get_db
from model import Student, StudentCreate
from service import StudentService

logger = logging_config.get_logger(__name__)
router = APIRouter(prefix="/students", tags=["students"])
student_service = StudentService()


@router.get("/{student_id}", response_model=Student)
def read_student(student_id: int, db: Session = Depends(get_db)):
    logger.info(f"Fetching student with ID: {student_id}")
    try:
        student = student_service.get_student(student_id, db)
        return student.model_dump()
    except ValueError as e:
        logger.error(f"Error fetching student with ID {student_id}: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))


@router.get("/", response_model=list[Student])
def read_students(db: Session = Depends(get_db)):
    logger.info("Fetching all students")
    try:
        students = student_service.get_students(db)
        return [student.model_dump() for student in students]
    except ValueError as e:
        logger.error(f"Error fetching students: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))


@router.post("/", response_model=Student)
def create_student(student_data: StudentCreate, db: Session = Depends(get_db)):
    logger.info(f"Creating new student with data: {student_data.model_dump()}")
    try:
        new_student = student_service.create_student(student_data.model_dump(), db)
        return new_student.model_dump()
    except ValueError as e:
        logger.error(f"Error creating student: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))


@router.put("/{student_id}", response_model=Student)
def update_student(
    student_id: int, student_data: StudentCreate, db: Session = Depends(get_db)
):
    logger.info(
        f"Updating student with ID: {student_id} with data: {student_data.model_dump()}"
    )
    try:
        updated_student = student_service.update_student(
            student_id, student_data.model_dump(), db
        )
        return updated_student.model_dump()
    except ValueError as e:
        logger.error(f"Error updating student with ID {student_id}: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(
            f"Unexpected error updating student with ID {student_id}: {str(e)}"
        )
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/{student_id}")
def delete_student(student_id: int, db: Session = Depends(get_db)):
    logger.info(f"Deleting student with ID: {student_id}")
    try:
        student_service.delete_student(student_id, db)
        return {"detail": "Student deleted successfully"}
    except ValueError as e:
        logger.error(f"Error deleting student with ID {student_id}: {str(e)}")
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(
            f"Unexpected error deleting student with ID {student_id}: {str(e)}"
        )
        raise HTTPException(status_code=500, detail=str(e))

================
File: service/__init__.py
================
from .course_service import CourseService
from .student_service import StudentService

__all__ = [
    "CourseService",
    "StudentService",
]

================
File: service/course_service.py
================
from dao.course_repository import CourseRepository
from model.course import Course


class CourseService:
    def __init__(self):
        self.course_repo = CourseRepository()

    def get_course(self, course_id: int, db) -> Course:
        return self.course_repo.get_course_by_id(course_id, db)

    def get_courses(self, db) -> list[Course]:
        return self.course_repo.get_all_courses(db)

    def create_course(self, course_data: dict, db) -> Course:
        return self.course_repo.create_course(course_data, db)

    def update_course(self, course_id: int, course_data: dict, db) -> Course:
        return self.course_repo.update_course(course_id, course_data, db)

    def delete_course(self, course_id: int, db) -> None:
        return self.course_repo.delete_course(course_id, db)

================
File: service/student_service.py
================
from dao import StudentRepository
from model import Student


class StudentService:
    def __init__(self):
        self.student_repo = StudentRepository()

    def get_student(self, student_id: int, db) -> Student:
        return self.student_repo.get_student_by_id(student_id, db)

    def get_students(self, db) -> list[Student]:
        return self.student_repo.get_all_students(db)

    def create_student(self, student_data: dict, db) -> Student:
        return self.student_repo.create_student(student_data, db)

    def update_student(self, student_id: int, student_data: dict, db) -> Student:
        return self.student_repo.update_student(student_id, student_data, db)

    def delete_student(self, student_id: int, db) -> None:
        return self.student_repo.delete_student(student_id, db)

================
File: sql/course.sql
================
CREATE TABLE IF NOT EXISTS course (
    course_id INTEGER PRIMARY KEY AUTOINCREMENT,
    course_name TEXT NOT NULL,
    credits INTEGER NOT NULL CHECK (credits > 0),
    department TEXT NOT NULL,
    semester TEXT NOT NULL CHECK (semester IN ('Fall', 'Spring', 'Summer')),
    year INTEGER NOT NULL
);

================
File: sql/student_course.sql
================
CREATE TABLE IF NOT EXISTS student_course (
    student_id INTEGER NOT NULL,
    course_id INTEGER NOT NULL,
    semester TEXT NOT NULL CHECK (semester IN ('Fall', 'Spring', 'Summer')),
    grade TEXT CHECK (grade IN ('A', 'B', 'C', 'D', 'F')),
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (course_id) REFERENCES course(course_id)
);

================
File: sql/student.sql
================
CREATE TABLE IF NOT EXISTS student (
    student_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INTEGER NOT NULL,
    enroll_year INTEGER NOT NULL,
    major TEXT NOT NULL,
    gpa REAL CHECK (gpa >= 0.0 AND gpa <= 4.0)
);

================
File: tests/test_app.py
================
import pytest
from fastapi.testclient import TestClient

from app import app

client = TestClient(app)


@pytest.fixture(autouse=True)
def setup_and_teardown():
    yield


def test_read_health():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"health": "ok"}

================
File: tests/test_courses.py
================
import pytest
from fastapi.testclient import TestClient

from app import app

client = TestClient(app)


@pytest.fixture(autouse=True)
def setup_and_teardown():
    yield


def test_course_api():
    course_data = {
        "course_name": "Test Course",
        "credits": 3,
        "department": "Test Department",
        "semester": "Fall",
        "year": 2023,
    }

    # test create api
    course_resp = client.post("/courses", json=course_data)
    assert course_resp.status_code == 200

    created_course = course_resp.json()
    course_id = created_course["course_id"]

    # test read api
    read_resp = client.get(f"/courses/{course_id}")
    assert read_resp.status_code == 200
    read_course = read_resp.json()
    assert read_course["course_name"] == course_data["course_name"]

    # test update api
    updated_course_data = {
        "course_name": "Updated Course",
        "credits": 4,
        "department": "Updated Department",
        "semester": "Spring",
        "year": 2024,
    }

    update_resp = client.put(f"/courses/{course_id}", json=updated_course_data)
    assert update_resp.status_code == 200
    updated_course = update_resp.json()
    assert updated_course["course_name"] == updated_course_data["course_name"]
    assert updated_course["credits"] == updated_course_data["credits"]
    assert updated_course["department"] == updated_course_data["department"]

    # test delete api
    delete_resp = client.delete(f"/courses/{course_id}")
    assert delete_resp.status_code == 200

    # test read deleted course
    read_deleted_resp = client.get(f"/courses/{course_id}")
    assert read_deleted_resp.status_code == 404

================
File: tests/test_students.py
================
import pytest
from fastapi.testclient import TestClient
from httpx import delete

from app import app
from model import student

client = TestClient(app)


@pytest.fixture(autouse=True)
def setup_and_teardown():
    yield


def test_students_api():
    student_data = {
        "name": "Test Student",
        "age": 20,
        "enroll_year": 2021,
        "major": "Test Major",
        "gpa": 3.5,
    }

    # test create api
    create_resp = client.post("/students", json=student_data)
    assert create_resp.status_code == 200
    created_student = create_resp.json()
    student_id = created_student["student_id"]
    assert created_student["name"] == student_data["name"]

    # test read api
    read_resp = client.get(f"/students/{student_id}")
    assert read_resp.status_code == 200
    read_student = read_resp.json()
    assert read_student["name"] == student_data["name"]
    assert read_student["age"] == student_data["age"]

    # test update api
    updated_student_data = {
        "name": "Updated Student",
        "age": 21,
        "enroll_year": 2022,
        "major": "Updated Major",
        "gpa": 3.8,
    }

    update_resp = client.put(f"/students/{student_id}", json=updated_student_data)
    assert update_resp.status_code == 200
    updated_student = update_resp.json()
    assert updated_student["name"] == updated_student_data["name"]
    assert updated_student["age"] == updated_student_data["age"]
    assert updated_student["major"] == updated_student_data["major"]

    # test delete api
    delete_resp = client.delete(f"/students/{student_id}")
    assert delete_resp.status_code == 200

    # test read deleted student
    read_deleted_resp = client.get(f"/students/{student_id}")
    assert read_deleted_resp.status_code == 404

================
File: .editorconfig
================
root = true

[*]
indent_style = space
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.py]
max_line_length = 88

================
File: .gitignore
================
# gitignore poetry and python stuff
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
# C extensions
*.so
# Distribution / packaging
.Python
env/
venv/
ENV/
env.bak/
venv.bak/
# Installer logs
pip-log.txt
pip-delete-this-directory.txt
# Unit test / coverage reports
htmlcov/
.tox/
.cover/
nosetests.xml
coverage.xml

================
File: .tool-versions
================
python 3.13.2
poetry 2.1.1
just 1.40.0

================
File: app.py
================
from fastapi import FastAPI

import logging_config
from routes.course_routes import router as course_router
from routes.student_routes import router as student_router

logger = logging_config.get_logger(__name__)

app = FastAPI()

# include routes
app.include_router(course_router)
app.include_router(student_router)


@app.get("/health")
def read_root():
    logger.info("Health check endpoint called")
    return {"health": "ok"}

================
File: db.py
================
import os

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import QueuePool

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///coursework.db")

engine = create_engine(
    DATABASE_URL,
    echo=True,
    connect_args={"check_same_thread": False},
    poolclass=QueuePool,
    pool_size=5,
    max_overflow=10,
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


def get_db():
    """
    Dependency that provides a database session and ensures it is closed after use.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

================
File: Justfile
================
default: install server

install:
  poetry update

test:
  poetry run pytest --maxfail=1 --disable-warnings -q

server:
  poetry run python server.py

server-alt:
  poetry run uvicorn app:app --host 0.0.0.0 --port 8000 --reload

================
File: logging_config.py
================
import logging
import os

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")

logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)


def get_logger(name: str) -> logging.Logger:
    logger = logging.getLogger(name)
    return logger

================
File: pyproject.toml
================
[project]
name = "coursework"
version = "0.1.0"
description = "coursework system to manage student courses"
authors = [
    {name = "Rui Chen",email = "rui@chenrui.dev"}
]
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "requests (>=2.32.3,<3.0.0)",
    "sqlalchemy (>=2.0.39,<3.0.0)",
    "pydantic (>=2.5.2,<3.0.0)",
    "fastapi (>=0.103.1,<1.0.0)",
    "uvicorn (>=0.24.0,<1.0.0)",
]


[build-system]
requires = ["poetry-core>=2.0.0,<3.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
package-mode = false

[tool.poetry.scripts]
serve = "server:main"

[tool.poetry.group.dev.dependencies]
pytest = "^8.3.5"

================
File: README.md
================
# backend

Backend for coursework project

## Dependencies

```sh
$ brew install mise sqlite
$ mise install
$ just server
```

## connect to sqlite

```sh
$ sqlite coursework.db
```

================
File: server.py
================
import uvicorn


def main():
    """Run the FastAPI application using uvicorn."""
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)


if __name__ == "__main__":
    main()



================================================================
End of Codebase
================================================================
